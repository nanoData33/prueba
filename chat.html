<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CohortIQ – Visualizador Clínico</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lucide@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
:root { --verde:#2f6e3e; --verde-oscuro:#245831; --gris:#3b3b3b; --fondo:#f5f7f5; --card:#fff; --sombra:rgba(0,0,0,0.1);}
*{box-sizing:border-box}
body{font-family:"Poppins",sans-serif;margin:0;background:var(--fondo);color:var(--gris);height:100vh;display:flex;flex-direction:column;}
header{background:var(--card);display:flex;justify-content:space-between;align-items:center;padding:15px 40px;box-shadow:0 2px 8px var(--sombra);}
header h1{color:var(--verde);display:flex;align-items:center;gap:8px;font-size:1.1rem;}
header button{background:var(--verde);color:white;border:none;border-radius:8px;padding:8px 16px;cursor:pointer;}
header button:hover{background:var(--verde-oscuro);}

/* --- INICIO CAMBIO: CSS Fijo 50/50 (CORREGIDO) --- */
main {
    flex: 1;
    display: grid;
    /* Forzamos 2 columnas siempre */
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    padding: 20px;
    min-height: 0;
}

/* Se elimina el @media query para que sea fijo */
.chat-box, .tabla-box {
    background: var(--card);
    border-radius: 12px;
    box-shadow: 0 4px 10px var(--sombra);
    padding: 20px;
    display: flex;
    flex-direction: column;
    min-height: 0; /* Para el scroll vertical */
    min-width: 0;  /* Para que el contenido no rompa el grid */
}
/* --- FIN CAMBIO --- */


/* --- CSS para layout 50/50 --- */
#tablaContainer {
    flex: 1; /* Hace que este div ocupe el espacio restante */
    overflow: auto; /* Añade scroll si la tabla es muy grande */
    min-height: 0; /* Asegura el comportamiento correcto del overflow en flex */
}

h2{text-align:center;color:var(--verde);margin:0 0 10px;}
.messages{flex:1;overflow:auto;background:#f8faf8;border-radius:10px;padding:15px;margin-bottom:10px;}
.msg{margin-bottom:12px;padding:12px 15px;border-radius:12px;max-width:100%;}
.msg.user{background:var(--verde);color:white;align-self:flex-end;}
.msg.bot{background:#e8f3e8;white-space:pre-wrap;}

/* --- CSS de Audio --- */
.input-area{display:flex;gap:10px;}
input{flex:1;padding:10px;border:1px solid #ccc;border-radius:10px;}
button.action{
    background:var(--verde);
    color:white;
    border:none;
    border-radius:10px;
    padding:10px 14px;
    cursor:pointer;
    flex-shrink: 0; /* Impide que los botones se encojan */
    display:flex;
    align-items:center;
    justify-content:center;
}
button.action:hover{background:var(--verde-oscuro);}

/* Estilo para el botón de grabar */
button.action.is-recording {
    background: #e74c3c; /* Rojo mientras graba */
    animation: pulse 1.s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
    100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
}
/* --- FIN CSS de Audio --- */

table{width:100%;border-collapse:collapse;margin-top:10px;font-size:0.9rem;}
th,td{border:1px solid #ddd;padding:10px;text-align:left; white-space: nowrap;}

/* Encabezado de tabla fijo */
th{
    background:var(--verde);
    color:white;
    position: sticky; /* Se adhiere a la parte superior */
    top: 0;           /* Pega al borde superior del scroll */
    z-index: 1;       /* Asegura que esté por encima de las filas */
}

tr:nth-child(even){background:#f5f7f5;}
.btn-group{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
.btn-chart{padding:8px 12px;border:none;border-radius:6px;cursor:pointer;}
.btn-rec{background:var(--verde);color:white;}
.btn-alt{background:#e6e8e6;}
.btn-alt:hover{background:#d3d5d3;}
#verDatasetBtn{margin-top:12px;background:var(--verde);color:white;border:none;border-radius:8px;padding:10px 16px;cursor:pointer;width:100%;}
#verDatasetBtn:hover{background:var(--verde-oscuro);}

/* Modal de Gráfico */
#chartModal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999;}
#chartModalContent{background:white;padding:20px;border-radius:10px;width:90%;max-width:900px;box-shadow:0 0 10px rgba(0,0,0,0.3);}
#closeModal{background:var(--verde);color:white;border:none;padding:8px 12px;border-radius:6px;float:right;cursor:pointer;margin-bottom:10px;}
#chartWrap{width:100%;height:440px;}
#chartWrap canvas{width:100%!important;height:100%!important;}

/* --- INICIO: NUEVOS ESTILOS PARA MODAL DE DATASET --- */
#datasetModal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.6);
    display: none; /* Oculto por defecto */
    align-items: center;
    justify-content: center;
    z-index: 10000; /* Por encima del modal de gráfico */
}
#datasetModalContent {
    background: white;
    padding: 20px;
    border-radius: 10px;
    width: 90%;  /* Más ancho */
    height: 90%; /* Más alto */
    max-width: 1400px; /* Límite más grande */
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    min-height: 0; /* Para que funcione el overflow en flex */
}

/* NUEVO: Header del Modal con botones */
.modal-header-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin-bottom: 10px;
    flex-shrink: 0;
}
.modal-header-controls h2 {
    margin: 0;
    text-align: left;
}
.modal-header-controls div {
    display: flex;
    gap: 10px;
}
/* Los botones #downloadCsvBtn y #closeDatasetModal usan .btn-chart, .btn-alt, .btn-rec */
/* FIN: Header del Modal */

#datasetInfoContainer {
    text-align: center;
    font-size: 0.95rem;
    color: #555;
    margin-bottom: 15px;
    flex-shrink: 0;
    word-break: break-all;
}
#datasetTableWrapper {
    flex: 1; /* Ocupa el espacio restante */
    overflow: auto; /* AÑADE SCROLL A LA TABLA */
    min-height: 0;
    width: 100%;
}

/* Estilos de la tabla dentro del modal */
#datasetTableWrapper table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
}
#datasetTableWrapper th, 
#datasetTableWrapper td {
    border: 1px solid #ddd;
    padding: 10px;
    text-align: left;
    white-space: nowrap; /* Evita que el texto se parta */
}
#datasetTableWrapper th {
    background: var(--verde);
    color: white;
    position: sticky; /* Encabezado fijo DENTRO del wrapper */
    top: 0;
    z-index: 1;
}
#datasetTableWrapper tr:nth-child(even) { 
    background: #f5f7f5; 
}
/* --- FIN: NUEVOS ESTILOS PARA MODAL DE DATASET --- */


footer{text-align:center;background:var(--card);padding:8px;color:#555;font-size:0.85rem;}
pre.debug{background:#222;color:#e3e3e3;padding:10px;border-radius:8px;overflow:auto}
</style>
</head>

<body>
<header>
  <h1><i data-lucide="stethoscope"></i> CohortIQ – Asistente Clínico</h1>
  <button onclick="window.location.href='index.html'">Volver al Inicio</button>
</header>

<main>
  <!-- Columna de Chat (izquierda) -->
  <div class="chat-box">
    <h2>Chat con el Agente</h2>
    <div id="messages" class="messages"></div>
    <div class="input-area">
      <input id="userInput" placeholder="Escribe tu mensaje o graba un audio...">
      <button class="action" id="sendBtn"><i data-lucide="send"></i></button>
      <button class="action" id="micBtn"><i data-lucide="mic"></i></button>
  </div>
  </div>

  <!-- Columna de Resultados (derecha) -->
  <div class="tabla-box">
    <h2>Resultados</h2>
    <div id="tablaContainer">Esperando resultados...</div>
  </div>
</main>


<!-- Modal gráfico -->
<div id="chartModal">
  <div id="chartModalContent">
    <button id="closeModal">Cerrar</button>
    <div id="chartWrap"><canvas id="chartCanvas"></canvas></div>
  </div>
</div>

<!-- --- INICIO: NUEVO HTML PARA MODAL DE DATASET --- -->
<div id="datasetModal">
  <div id="datasetModalContent">
    <!-- INICIO: Contenedor para botones/título del modal -->
    <div class="modal-header-controls">
        <h2>Dataset Completo</h2>
        <div>
            <!-- NUEVO BOTÓN CSV -->
            <button id="downloadCsvBtn" class="btn-chart btn-alt">Descargar CSV</button>
            <button id="closeDatasetModal" class="btn-chart btn-rec">Cerrar</button>
        </div>
    </div>
    <!-- FIN: Contenedor para botones/título del modal -->
    <div id="datasetInfoContainer">Cargando...</div>
    <div id="datasetTableWrapper">
        <!-- La tabla completa se generará aquí -->
    </div>
  </div>
</div>
<!-- --- FIN: NUEVO HTML PARA MODAL DE DATASET --- -->


<footer>© 2025 CohortIQ – Plataforma Inteligente de Apoyo Clínico</footer>

<script>
lucide.createIcons();

// --- URLs de Webhooks (actualizadas por ti) ---
const webhookText = "https://rubaseval.app.n8n.cloud/webhook/dedaluschataudio";
const webhookGraf = "https://rubaseval.app.n8n.cloud/webhook/grafico";
const webhookData = "https://rubaseval.app.n8n.cloud/webhook/dataset";
const webhookGmail = "https://rubaseval.app.n8n.cloud/webhook/escribir-gmail"; 
const webhookEnviarGmail = "https://rubaseval.app.n8n.cloud/webhook/enviar-gmail";
// --- Fin URLs Webhooks ---

const supabaseUrl = "https://tmolxeszsgkffurhrcxy.supabase.co";
const supabaseKey = "eyJhbGciOiJIZzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRtb2x4ZXN6c2drZmZ1cmhyY3h5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA5ODA4NDgsImV4cCI6MjA3NjU1Njg0OH0.UAEsNX7CpFXbns9ONynstAAKdcvmZUfsX5J6cOTE6Pw";
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

let ultimaConsulta = "";
let ultimaConsultaSQL = "";
let ultimaX = "";
let ultimaY = "";
let chartInstance = null;

// --- INICIO: NUEVAS VARIABLES GLOBALES PARA CSV ---
let currentDataset = {
    columns: [],
    rows: []
};
// --- FIN: NUEVAS VARIABLES GLOBALES PARA CSV ---

// --- INICIO: NUEVAS VARIABLES PARA MEMORIA ---
let conversationHistory = [];
const MAX_HISTORY_TURNS = 5; // 5 turnos (user + bot) = 10 items
// --- FIN: NUEVAS VARIABLES PARA MEMORIA ---

// --- INICIO NUEVAS VARIABLES AUDIO ---
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
const micBtn = document.getElementById("micBtn");
// --- FIN NUEVAS VARIABLES AUDIO ---


// Event Listeners (Texto y Enter)
document.addEventListener("keydown", e => { if (e.key === "Enter") sendText(); });
document.getElementById("sendBtn").addEventListener("click", sendText);

// --- INICIO NUEVO EVENT LISTENER AUDIO ---
micBtn.addEventListener("click", toggleRecording);
// --- FIN NUEVO EVENT LISTENER AUDIO ---


function appendMessage(sender, text, html = false) {
  const msg = document.createElement("div");
  msg.className = "msg " + sender;
  msg.innerHTML = html ? text : text.replace(/\n/g, "<br>");
  const box = document.getElementById("messages");
  box.appendChild(msg);
  box.scrollTop = box.scrollHeight;
  return msg; // Devuelve el elemento para adjuntar listeners
}

async function sendText() {
  const input = document.getElementById("userInput");
  const text = input.value.trim();
  if (!text) return;
  appendMessage("user", text);
  input.value = "";
  appendMessage("bot", "Consultando al agente...");

  // --- INICIO CAMBIO MEMORIA ---
  // 1. Prepara el historial de USUARIO para enviar
  const userHistoryString = getFormattedUserHistoryString();
  
  // 2. Añade el mensaje actual del usuario al historial local
  conversationHistory.push({ role: "user", content: text });
  // --- FIN CAMBIO MEMORIA ---

  try {
    const res = await fetch(webhookText, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      // 3. Envía la consulta actual Y el historial de usuario
      body: JSON.stringify({
          type:"text", 
          content: text, // Consulta actual
          history: userHistoryString // Historial de usuario formateado
      })
    });
    
    const rawResponse = await res.text();
    if (!rawResponse) {
        throw new Error("Respuesta vacía del servidor (webhook)");
    }
    
    const data = JSON.parse(rawResponse);

    document.querySelector(".msg.bot:last-child").remove();

    let hasHandled = false; 
    let botResponseContent = ""; // Para guardar la respuesta del bot

    if (data.tabla) {
      renderMarkdownTable(data.cohorte, data.tabla, data.n_total);
      ultimaConsulta = data.consulta || "";
      ultimaConsultaSQL = data.sql || "";
      hasHandled = true;
      botResponseContent = `Tabla: ${data.cohorte}\n${data.tabla}`; 
    }

    if (data.gmail && data.gmail === "True" && data.consulta) {
      renderGmailButton(data.consulta);
      hasHandled = true;
      if (!botResponseContent) botResponseContent = "Acción de Gmail sugerida.";
    }

    if (data.respuesta && !data.tabla) {
      appendMessage("bot", data.respuesta);
      hasHandled = true;
      botResponseContent = data.respuesta;
    } 
    
    if (!hasHandled) {
      appendMessage("bot", "No se ha encontrado información.");
      botResponseContent = "No se ha encontrado información.";
    }

    // --- INICIO CAMBIO MEMORIA ---
    // 4. Añade la respuesta del bot al historial local
    if (botResponseContent) {
        conversationHistory.push({ role: "bot", content: botResponseContent });
    }

    // 5. Llama a la función de limpieza
    pruneHistory();
    // --- FIN CAMBIO MEMORIA ---

  } catch (err) {
    console.error("Error en sendText:", err);
    document.querySelector(".msg.bot:last-child")?.remove();
    appendMessage("bot", "Error al conectar con el agente. " + err.message);
  }
}


// --- INICIO NUEVAS FUNCIONES DE AUDIO ---

function toggleRecording() {
  if (!isRecording) {
    startRecording();
  } else {
    stopRecording();
  }
}

async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    
    mediaRecorder.ondataavailable = event => {
      audioChunks.push(event.data);
    };
    
    mediaRecorder.onstop = () => {
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      audioChunks = [];
      sendAudio(audioBlob); // Envía el Blob binario
    };
    
    mediaRecorder.start();
    isRecording = true;
    micBtn.innerHTML = `<i data-lucide="stop-circle"></i>`;
    micBtn.classList.add("is-recording");
    lucide.createIcons();
  } catch (err) {
    console.error("Error starting recording:", err);
    appendMessage("bot", "Error al acceder al micrófono. Asegúrate de dar permiso.");
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
    isRecording = false;
    micBtn.innerHTML = `<i data-lucide="mic"></i>`;
    micBtn.classList.remove("is-recording");
    lucide.createIcons();
    mediaRecorder.stream.getTracks().forEach(track => track.stop());
  }
}

async function sendAudio(audioBlob) {
  appendMessage("bot", "Procesando audio...");

  try {
    const formData = new FormData();
    formData.append('file', audioBlob, 'audio.webm'); 

    // --- INICIO CAMBIO MEMORIA ---
    // 1. Añade el historial de USUARIO formateado al FormData
    formData.append('history', getFormattedUserHistoryString());
    // --- FIN CAMBIO MEMORIA ---

    const res = await fetch(webhookText, {
      method: "POST",
      body: formData
    });
    
    const rawResponse = await res.text();
    if (!rawResponse) {
        throw new Error("Respuesta vacía del servidor (webhook)");
    }

    const data = JSON.parse(rawResponse);

    document.querySelector(".msg.bot:last-child").remove();

    let hasHandled = false; 
    let botResponseContent = ""; // Para guardar la respuesta

    if (data.consulta) {
        appendMessage("user", `[Audio] ${data.consulta}`);
        ultimaConsulta = data.consulta;
        // --- INICIO CAMBIO MEMORIA ---
        // 2. Añade la transcripción del usuario al historial local
        conversationHistory.push({ role: "user", content: data.consulta });
        // --- FIN CAMBIO MEMORIA ---
    }

    if (data.tabla) {
      renderMarkdownTable(data.cohorte, data.tabla, data.n_total);
      ultimaConsultaSQL = data.sql || "";
      hasHandled = true;
      botResponseContent = `Tabla: ${data.cohorte}\n${data.tabla}`;
    }

    if (data.gmail && data.gmail === "True") {
      renderGmailButton(data.consulta || "Acción de audio"); 
      hasHandled = true;
      if (!botResponseContent) botResponseContent = "Acción de Gmail sugerida.";
    }

    if (data.respuesta && !data.tabla) {
      appendMessage("bot", data.respuesta);
      hasHandled = true;
      botResponseContent = data.respuesta;
    } 
    
    if (!hasHandled) {
      appendMessage("bot", "No se ha encontrado información.");
      botResponseContent = "No se ha encontrado información.";
    }

    // --- INICIO CAMBIO MEMORIA ---
    // 3. Añade la respuesta del bot al historial local
    if (botResponseContent) {
        conversationHistory.push({ role: "bot", content: botResponseContent });
    }
    
    // 4. Llama a la función de limpieza
    pruneHistory();
    // --- FIN CAMBIO MEMORIA ---

  } catch (err) {
    console.error("Error en sendAudio:", err);
    document.querySelector(".msg.bot:last-child")?.remove();
    appendMessage("bot", "Error al procesar el audio. " + err.message);
  }
}
// --- FIN NUEVAS FUNCIONES DE AUDIO ---

// --- INICIO: NUEVA FUNCIÓN PARA MEMORIA (Formateo de USUARIO) ---
function getFormattedUserHistoryString() {
    // Filtra solo las consultas del usuario
    const userHistory = conversationHistory.filter(item => item.role === 'user');
    
    if (userHistory.length === 0) {
        return "Consultas anteriores: (ninguna)"; // Devuelve un string, no un objeto
    }
    
    let historyString = "Consultas anteriores:\n";
    userHistory.forEach(item => {
        // Limpiamos los saltos de línea
        const cleanContent = (item.content || "").replace(/\n/g, ' ');
        historyString += `- ${cleanContent}\n`;
    });
    return historyString;
}
// --- FIN: NUEVA FUNCIÓN PARA MEMORIA (Formateo de USUARIO) ---

// --- INICIO: NUEVA FUNCIÓN PARA MEMORIA ---
function pruneHistory() {
    // MAX_HISTORY_TURNS = 5. (5 user + 5 bot = 10 items)
    const maxItems = MAX_HISTORY_TURNS * 2; 
    while (conversationHistory.length > maxItems) {
        // Quita el elemento más antiguo (primero)
        conversationHistory.shift(); 
    }
}
// --- FIN: NUEVA FUNCIÓN PARA MEMORIA ---


// --- FUNCIÓN renderMarkdownTable (CORREGIDA Y ROBUSTA) ---
function renderMarkdownTable(tituloCohorte, tablaString, mensajeTotal) {
  const lines = tablaString.trim().split("\n").filter(l => l.includes("|"));
  if (lines.length < 2) return;

  /**
   * Helper robusto para parsear una fila de Markdown.
   * Divide por "|", quita espacios y elimina los elementos vacíos ("")
   * que se generan por los pipes "|" al inicio o al final.
   * @param {string} line - La línea de texto de la tabla.
   * @returns {string[]} Un array de celdas limpias.
   */
  function parseRow(line) {
      const cells = line.split("|").map(c => c.trim());
      // Si la línea empieza con "|", el primer elemento es "". Lo quitamos.
      if (cells[0] === "") {
          cells.shift();
      }
      // Si la línea termina con "|", el último elemento es "". Lo quitamos.
      if (cells.length > 0 && cells[cells.length - 1] === "") {
          cells.pop();
      }
      return cells;
  }

  // Parseamos los headers y los filtramos (los headers no pueden estar vacíos)
  const headers = parseRow(lines[0]).filter(Boolean);
  
  // Parseamos las filas. Usamos la misma lógica, pero NO filtramos
  // para poder conservar celdas de datos vacías (ej: pronostico).
  const rows = lines.slice(2).map(line => parseRow(line));
  
  // --- FIN DE LA CORRECCIÓN ---

  let html = "";
  if (tituloCohorte) {
    html += `<h3 style="text-align: left; margin-top: 0;">Cohorte: ${tituloCohorte}</h3>`;
  }

  html += "<table><thead><tr>";
  headers.forEach(h => html += `<th>${h}</th>`);
  html += "</tr></thead><tbody>";
  rows.forEach(r => html += "<tr>" + r.map(c => `<td>${c}</td>`).join("") + "</tr>");
  html += "</tbody></table>";

  if (mensajeTotal) {
    html += `<p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 12px;">${mensajeTotal}</p>`;
  }

  html += `<button id="verDatasetBtn">Ver resultado completo</button>`;
  
  document.getElementById("tablaContainer").innerHTML = html;
  // IMPORTANTE: Se añade el listener aquí, después de crear el botón
  const btn = document.getElementById("verDatasetBtn");
  if (btn) {
      btn.addEventListener("click", enviarDataset);
  }
}

function renderChartButtonsInChat() {
  const tipos = ["bar", "line", "scatter", "pie", "histogram"];
  let html = `<p><strong>El agente sugiere:</strong> selecciona el tipo de gráfico que deseas visualizar.</p><div class="btn-group">`;
  tipos.forEach(t => html += `<button class="btn-chart btn-alt" data-tipo="${t}">${t}</button>`);
  html += "</div>";
  
  const msgElement = appendMessage("bot", html, true);

  msgElement.querySelectorAll(".btn-chart").forEach(btn => 
    btn.addEventListener("click", () => manejarGrafico(btn.dataset.tipo))
  );
}

async function manejarGrafico(tipo) {
  appendMessage("bot", `Generando gráfico tipo '${tipo}'...`);
  try {
    const payload = {
      consulta: ultimaConsulta,
      sql: ultimaConsultaSQL,
    decision: tipo
    };

    const res = await fetch(webhookGraf, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    if (data.sql && data.x && data.y) {
      await renderChartFromSQL(data.sql, data.x, data.y, tipo);
    } else {
      appendMessage("bot", "Datos insuficientes para graficar.");
    }
  } catch {
    appendMessage("bot", "Error al conectar con el agente.");
}
}

async function renderChartFromSQL(sql, xField, yField, chartType) {
  try {
    const { data, error } = await supabase.rpc("execute_sql_query", { query: sql });
    if (error || !data?.length) {
      appendMessage("bot", "Sin resultados en la consulta para graficar.");
      return;
    }

    const labels = data.map(row => row[xField]);
    const values = data.map(row => parseFloat(row[yField])).filter(v => !isNaN(v));
    if (!values.length) {
      appendMessage("bot", "No hay valores numéricos válidos para graficar.");
      return;
    }

    const modal = document.getElementById("chartModal");
    modal.style.display = "flex";
    const ctx = document.getElementById("chartCanvas").getContext("2d");
    if (chartInstance) chartInstance.destroy();

    chartInstance = new Chart(ctx, {
      type: chartType === "histogram" ? "bar" : chartType,
      data: {
        labels,
        datasets: [{
          label: `${yField} vs ${xField}`,
          data: values,
          backgroundColor: "rgba(47,110,62,0.6)",
          borderColor: "rgba(47,110,62,1)",
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: { beginAtZero: true, title: { display: true, text: yField } },
          x: { title: { display: true, text: xField } }
        }
      }
    });
  } catch {
    appendMessage("bot", "Error al generar el gráfico desde Supabase.");
 }
}

// --- INICIO: FUNCIÓN enviarDataset MODIFICADA ---
async function enviarDataset() {
  if (!ultimaConsultaSQL) {
    appendMessage("bot", "No hay SQL disponible para enviar.");
    return;
  }
  appendMessage("bot", "Cargando dataset completo...");
  
  try {
    const res = await fetch(webhookData, {
      method: "POST",
     headers: {"Content-Type": "application/json"},
      body: JSON.stringify({ sql: ultimaConsultaSQL })
    });
    const data = await res.json();
    
    // Quita el mensaje "Cargando..."
    document.querySelector(".msg.bot:last-child")?.remove(); 
    
    // Llama a la nueva función para renderizar el modal
    renderDatasetModal(data);

  } catch(err) {
      console.error("Error en enviarDataset:", err);
      const loadingMsg = document.querySelector(".msg.bot:last-child");
      if (loadingMsg) {
          loadingMsg.innerHTML = "Error al solicitar el dataset completo.";
      } else {
          appendMessage("bot", "Error al solicitar el dataset completo.");
      }
  }
}
// --- FIN: FUNCIÓN enviarDataset MODIFICADA ---

// --- INICIO: NUEVA FUNCIÓN PARA RENDERIZAR EL MODAL DEL DATASET ---
function renderDatasetModal(data) {
    const tableWrapper = document.getElementById('datasetTableWrapper');
    const infoContainer = document.getElementById('datasetInfoContainer');

    try {
        // Parsear los datos anidados
        const columns = (data.columns && JSON.parse(data.columns)) || [];
        const rows = (data.rows && JSON.parse(data.rows)) || [];

        // --- INICIO: GUARDAR DATOS PARA CSV ---
        currentDataset.columns = columns;
        currentDataset.rows = rows;
        // --- FIN: GUARDAR DATOS PARA CSV ---

        const total = data.total_registros || (rows ? rows.length : 0);
        const sql = data.sql || "No se proporcionó SQL.";

        // Poblar el contenedor de información
        infoContainer.innerHTML = `
            <strong>Total de registros:</strong> ${total} <br>
            <small style="color: #777;"><strong>Consulta SQL:</strong> ${sql}</small>
        `;

        // Construir la tabla HTML
        let html = "<table><thead><tr>";
        columns.forEach(col => {
            html += `<th>${col}</th>`;
        });
        html += "</tr></thead><tbody>";

        rows.forEach(row => {
            html += "<tr>";
            row.forEach(cell => {
                // Escapar HTML para seguridad
                const safeCell = cell !== null ? String(cell).replace(/</g, "&lt;").replace(/>/g, "&gt;") : "";
                html += `<td>${safeCell}</td>`;
            });
            html += "</tr>";
        });
        html += "</tbody></table>";
        
        // Inyectar la tabla y mostrar el modal
        tableWrapper.innerHTML = html;
        document.getElementById('datasetModal').style.display = 'flex';

    } catch (e) {
        console.error("Error al renderizar el modal del dataset:", e);
        appendMessage("bot", `Error al procesar los datos: ${e.message}`);
    }
}
// --- FIN: NUEVA FUNCIÓN PARA RENDERIZAR EL MODAL DEL DATASET ---


// Listener para cerrar el modal de gráfico
document.getElementById("closeModal").addEventListener("click", () => {
  document.getElementById("chartModal").style.display = "none";
});

// --- INICIO: NUEVO LISTENER PARA CERRAR EL MODAL DEL DATASET ---
document.getElementById("closeDatasetModal").addEventListener("click", () => {
  document.getElementById("datasetModal").style.display = "none";
  // Opcional: Limpiar la tabla para liberar memoria
  document.getElementById('datasetTableWrapper').innerHTML = ""; 
  document.getElementById('datasetInfoContainer').innerHTML = "Cargando...";
});
// --- FIN: NUEVO LISTENER PARA CERRAR EL MODAL DEL DATASET ---

// --- INICIO: NUEVA FUNCIÓN Y LISTENER PARA DESCARGAR CSV ---
function downloadCSV() {
    const { columns, rows } = currentDataset;
    if (columns.length === 0 || rows.length === 0) {
        appendMessage("bot", "No hay datos para descargar.");
        return;
    }

    // Función para escapar celdas de CSV
    const escapeCsvCell = (cell) => {
        let str = String(cell === null ? "" : cell);
        // Si la celda contiene comas, comillas dobles o saltos de línea, envolver entre comillas dobles
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            // Escapar comillas dobles existentes (reemplazando " por "")
            str = str.replace(/"/g, '""');
            str = `"${str}"`;
        }
        return str;
    };

    // 1. Crear la fila de cabecera
    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += columns.map(escapeCsvCell).join(",") + "\r\n";

    // 2. Crear las filas de datos
    rows.forEach(row => {
        csvContent += row.map(escapeCsvCell).join(",") + "\r\n";
    });

    // 3. Crear el enlace y disparar la descarga
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "cohortiq_dataset.csv");
    document.body.appendChild(link); // Necesario para Firefox
    
    link.click();
    
    document.body.removeChild(link);
}

// Añadir el listener al nuevo botón
document.getElementById("downloadCsvBtn").addEventListener("click", downloadCSV);
// --- FIN: NUEVA FUNCIÓN Y LISTENER PARA DESCARGAR CSV ---


// --- INICIO FUNCIONES GMAIL ---
function renderGmailButton(consulta) {
  const html = `
    <p><strong>Acción sugerida:</strong></p>
    <div class="btn-group">
      <button class="btn-chart btn-rec" id="gmailBtn">Generar Gmail</button>
    </div>`;
  
  const msgElement = appendMessage("bot", html, true);
  const button = msgElement.querySelector("#gmailBtn");

  if (button) {
    button.addEventListener("click", () => handleGmailGeneration(consulta));
  } else {
    console.error("Error: No se pudo adjuntar el listener al #gmailBtn");
  }
}

async function handleGmailGeneration(consulta) {
  const btn = document.getElementById("gmailBtn"); 
  if (btn) {
    btn.disabled = true;
    btn.textContent = "Generando...";
    btn.id = "";
  }
  
  appendMessage("bot", "Generando borrador de Gmail...");

  try {
    const payload = { "consulta": consulta };

    const res = await fetch(webhookGmail, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    document.querySelector(".msg.bot:last-child")?.remove(); 

    if (data.gmail) {
      const uniqueButtonId = `enviar-btn-${Date.now()}`;
      const emailHtml = `
        <div style="white-space: pre-wrap; background: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; padding: 12px;">
          ${data.gmail}
        </div>
        <div class="btn-group" style="margin-top: 10px;">
          <button class="btn-chart btn-rec" id="${uniqueButtonId}">Enviar Gmail</button>
        </div>
      `;
      
      const msgElement = appendMessage("bot", emailHtml, true);
      const sendButton = msgElement.querySelector(`#${uniqueButtonId}`);
      
      if (sendButton) {
        // Pasa el ID del botón y el cuerpo del email (data.gmail)
        sendButton.addEventListener("click", () => handleSendGmail(uniqueButtonId, data.gmail));
      }

    } else {
      appendMessage("bot", "No se pudo generar el cuerpo del Gmail.");
    }

  } catch (err) {
    document.querySelector(".msg.bot:last-admin")?.remove();
    console.error("Error en handleGmailGeneration:", err);
    appendMessage("bot", "Error al conectar con el servicio de Gmail.");
  }
}

async function handleSendGmail(buttonId, emailBody) {
  const btn = document.getElementById(buttonId);
  if (!btn || btn.disabled) return;

  btn.disabled = true;
  btn.textContent = "Enviando...";

  try {
    const payload = { "output": emailBody };

    const res = await fetch(webhookEnviarGmail, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      throw new Error(`Error del servidor: ${res.statusText}`);
    }

    appendMessage("bot", "✅ Gmail Enviado Correctamente.");
    btn.style.display = 'none';

  } catch (err) {
    console.error("Error en handleSendGmail:", err);
    appendMessage("bot", "❌ Error al enviar el Gmail. Inténtalo de nuevo.");
    btn.disabled = false;
    btn.textContent = "Enviar Gmail";
  }
}
// --- FIN FUNCIONES GMAIL ---

</script>
</body>
</html>

