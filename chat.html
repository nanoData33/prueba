<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CohortIQ – Visualizador Clínico</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lucide@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
:root { --verde:#2f6e3e; --verde-oscuro:#245831; --gris:#3b3b3b; --fondo:#f5f7f5; --card:#fff; --sombra:rgba(0,0,0,0.1);}
*{box-sizing:border-box}
body{font-family:"Poppins",sans-serif;margin:0;background:var(--fondo);color:var(--gris);height:100vh;display:flex;flex-direction:column;}
header{background:var(--card);display:flex;justify-content:space-between;align-items:center;padding:15px 40px;box-shadow:0 2px 8px var(--sombra);}
header h1{color:var(--verde);display:flex;align-items:center;gap:8px;font-size:1.1rem;}
header button{background:var(--verde);color:white;border:none;border-radius:8px;padding:8px 16px;cursor:pointer;}
header button:hover{background:var(--verde-oscuro);}

/* --- INICIO CAMBIO: CSS Fijo 50/50 --- */
main {
    flex: 1;
    display: grid;
    /* Forzamos 2 columnas siempre */
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    padding: 20px;
    min-height: 0;
}

/* Se elimina el @media query para que sea fijo */

.chat-box, .tabla-box {
    background: var(--card);
    border-radius: 12px;
    box-shadow: 0 4px 10px var(--sombra);
    padding: 20px;
    display: flex;
    flex-direction: column;
    min-height: 0; /* Para el scroll vertical */
    min-width: 0;  /* Para que el contenido no rompa el grid */
}
/* --- FIN CAMBIO --- */


/* --- CSS para layout 50/50 --- */
#tablaContainer {
    flex: 1; /* Hace que este div ocupe el espacio restante */
    overflow: auto; /* Añade scroll si la tabla es muy grande */
    min-height: 0; /* Asegura el comportamiento correcto del overflow en flex */
}

h2{text-align:center;color:var(--verde);margin:0 0 10px;}
.messages{flex:1;overflow:auto;background:#f8faf8;border-radius:10px;padding:15px;margin-bottom:10px;}
.msg{margin-bottom:12px;padding:12px 15px;border-radius:12px;max-width:100%;}
.msg.user{background:var(--verde);color:white;align-self:flex-end;}
.msg.bot{background:#e8f3e8;white-space:pre-wrap;}

/* --- CSS de Audio --- */
.input-area{display:flex;gap:10px;}
input{flex:1;padding:10px;border:1px solid #ccc;border-radius:10px;}
button.action{
    background:var(--verde);
    color:white;
    border:none;
    border-radius:10px;
    padding:10px 14px;
    cursor:pointer;
    flex-shrink: 0; /* Impide que los botones se encojan */
    display:flex;
    align-items:center;
    justify-content:center;
}
button.action:hover{background:var(--verde-oscuro);}

/* Estilo para el botón de grabar */
button.action.is-recording {
    background: #e74c3c; /* Rojo mientras graba */
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
    100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
}
/* --- FIN CSS de Audio --- */

table{width:100%;border-collapse:collapse;margin-top:10px;font-size:0.9rem;}
th,td{border:1px solid #ddd;padding:10px;text-align:left;}

/* Encabezado de tabla fijo */
th{
    background:var(--verde);
    color:white;
    position: sticky; /* Se adhiere a la parte superior */
    top: 0;           /* Pega al borde superior del scroll */
    z-index: 1;       /* Asegura que esté por encima de las filas */
}

tr:nth-child(even){background:#f5f7f5;}
.btn-group{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
.btn-chart{padding:8px 12px;border:none;border-radius:6px;cursor:pointer;}
.btn-rec{background:var(--verde);color:white;}
.btn-alt{background:#e6e8e6;}
.btn-alt:hover{background:#d3d5d3;}
#verDatasetBtn{margin-top:12px;background:var(--verde);color:white;border:none;border-radius:8px;padding:10px 16px;cursor:pointer;width:100%;}
#verDatasetBtn:hover{background:var(--verde-oscuro);}
#chartModal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999;}
#chartModalContent{background:white;padding:20px;border-radius:10px;width:90%;max-width:900px;box-shadow:0 0 10px rgba(0,0,0,0.3);}
#closeModal{background:var(--verde);color:white;border:none;padding:8px 12px;border-radius:6px;float:right;cursor:pointer;margin-bottom:10px;}
#chartWrap{width:100%;height:440px;}
#chartWrap canvas{width:100%!important;height:100%!important;}
footer{text-align:center;background:var(--card);padding:8px;color:#555;font-size:0.85rem;}
pre.debug{background:#222;color:#e3e3e3;padding:10px;border-radius:8px;overflow:auto}
</style>
</head>

<body>
<header>
  <h1><i data-lucide="stethoscope"></i> CohortIQ – Asistente Clínico</h1>
  <button onclick="window.location.href='index.html'">Volver al Inicio</button>
</header>

<!-- --- INICIO CAMBIO DE ORDEN --- -->
<main>
  <!-- Columna de Chat (ahora a la izquierda) -->
  <div class="chat-box">
    <h2>Chat con el Agente</h2>
    <div id="messages" class="messages"></div>
    <div class="input-area">
      <input id="userInput" placeholder="Escribe tu mensaje o graba un audio...">
      <button class="action" id="sendBtn"><i data-lucide="send"></i></button>
      <button class="action" id="micBtn"><i data-lucide="mic"></i></button>
  </div>
  </div>

  <!-- Columna de Resultados (ahora a la derecha) -->
  <div class="tabla-box">
    <h2>Resultados</h2>
    <div id="tablaContainer">Esperando resultados...</div>
  </div>
</main>
<!-- --- FIN CAMBIO DE ORDEN --- -->


<!-- Modal gráfico -->
<div id="chartModal">
  <div id="chartModalContent">
    <button id="closeModal">Cerrar</button>
    <div id="chartWrap"><canvas id="chartCanvas"></canvas></div>
  </div>
</div>

<footer>© 2025 CohortIQ – Plataforma Inteligente de Apoyo Clínico</footer>

<script>
lucide.createIcons();

// --- URLs de Webhooks (actualizadas por ti) ---
const webhookText = "https://rubaseval.app.n8n.cloud/webhook/dedaluschataudio";
const webhookGraf = "https://rubaseval.app.n8n.cloud/webhook/grafico";
const webhookData = "https://rubaseval.app.n8n.cloud/webhook/dataset";
const webhookGmail = "https://rubaseval.app.n8n.cloud/webhook/escribir-gmail"; 
const webhookEnviarGmail = "https://rubaseval.app.n8n.cloud/webhook/enviar-gmail";
// --- Fin URLs Webhooks ---

const supabaseUrl = "https://tmolxeszsgkffurhrcxy.supabase.co";
const supabaseKey = "eyJhbGciOiJIZzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRtb2x4ZXN6c2drZmZ1cmhyY3h5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA5ODA4NDgsImV4cCI6MjA3NjU1Njg0OH0.UAEsNX7CpFXbns9ONynstAAKdcvmZUfsX5J6cOTE6Pw";
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

let ultimaConsulta = "";
let ultimaConsultaSQL = "";
let ultimaX = "";
let ultimaY = "";
let chartInstance = null;

// --- INICIO NUEVAS VARIABLES AUDIO ---
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
const micBtn = document.getElementById("micBtn");
// --- FIN NUEVAS VARIABLES AUDIO ---


// Event Listeners (Texto y Enter)
document.addEventListener("keydown", e => { if (e.key === "Enter") sendText(); });
document.getElementById("sendBtn").addEventListener("click", sendText);

// --- INICIO NUEVO EVENT LISTENER AUDIO ---
micBtn.addEventListener("click", toggleRecording);
// --- FIN NUEVO EVENT LISTENER AUDIO ---


function appendMessage(sender, text, html = false) {
  const msg = document.createElement("div");
  msg.className = "msg " + sender;
  msg.innerHTML = html ? text : text.replace(/\n/g, "<br>");
  const box = document.getElementById("messages");
  box.appendChild(msg);
  box.scrollTop = box.scrollHeight;
  return msg; // Devuelve el elemento para adjuntar listeners
}

async function sendText() {
  const input = document.getElementById("userInput");
  const text = input.value.trim();
  if (!text) return;
  appendMessage("user", text);
  input.value = "";
  appendMessage("bot", "Consultando al agente...");

  try {
    const res = await fetch(webhookText, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({type:"text", content:text})
    });
    
    const rawResponse = await res.text();
    if (!rawResponse) {
        throw new Error("Respuesta vacía del servidor (webhook)");
    }
    
    const data = JSON.parse(rawResponse);

    document.querySelector(".msg.bot:last-child").remove();

    let hasHandled = false; 

    if (data.tabla) {
      renderMarkdownTable(data.cohorte, data.tabla, data.n_total);
      ultimaConsulta = data.consulta || "";
      ultimaConsultaSQL = data.sql || "";
      hasHandled = true;
    }

    if (data.gmail && data.gmail === "True" && data.consulta) {
      renderGmailButton(data.consulta);
      hasHandled = true;
    }

    if (data.respuesta && !data.tabla) {
      appendMessage("bot", data.respuesta);
      hasHandled = true;
    } 
    
    if (!hasHandled) {
      appendMessage("bot", "No se ha encontrado información.");
    }

  } catch (err) {
    console.error("Error en sendText:", err);
    document.querySelector(".msg.bot:last-child")?.remove();
    appendMessage("bot", "Error al conectar con el agente. " + err.message);
  }
}


// --- INICIO NUEVAS FUNCIONES DE AUDIO ---

function toggleRecording() {
  if (!isRecording) {
    startRecording();
  } else {
    stopRecording();
  }
}

async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    
    mediaRecorder.ondataavailable = event => {
      audioChunks.push(event.data);
    };
    
    mediaRecorder.onstop = () => {
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      audioChunks = [];
      sendAudio(audioBlob); // Envía el Blob binario
    };
    
    mediaRecorder.start();
    isRecording = true;
    micBtn.innerHTML = `<i data-lucide="stop-circle"></i>`;
    micBtn.classList.add("is-recording");
    lucide.createIcons();
  } catch (err) {
    console.error("Error starting recording:", err);
    appendMessage("bot", "Error al acceder al micrófono. Asegúrate de dar permiso.");
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
    isRecording = false;
    micBtn.innerHTML = `<i data-lucide="mic"></i>`;
    micBtn.classList.remove("is-recording");
    lucide.createIcons();
    mediaRecorder.stream.getTracks().forEach(track => track.stop());
  }
}

async function sendAudio(audioBlob) {
  appendMessage("bot", "Procesando audio...");

  try {
    const formData = new FormData();
    formData.append('file', audioBlob, 'audio.webm'); 

    const res = await fetch(webhookText, {
      method: "POST",
      body: formData
    });
    
    const rawResponse = await res.text();
    if (!rawResponse) {
        throw new Error("Respuesta vacía del servidor (webhook)");
    }

    const data = JSON.parse(rawResponse);

    document.querySelector(".msg.bot:last-child").remove();

    let hasHandled = false; 

    if (data.consulta) {
        appendMessage("user", `[Audio] ${data.consulta}`);
        ultimaConsulta = data.consulta;
    }

    if (data.tabla) {
      renderMarkdownTable(data.cohorte, data.tabla, data.n_total);
      ultimaConsultaSQL = data.sql || "";
      hasHandled = true;
    }

    if (data.gmail && data.gmail === "True") {
      renderGmailButton(data.consulta || "Acción de audio"); 
      hasHandled = true;
    }

    if (data.respuesta && !data.tabla) {
      appendMessage("bot", data.respuesta);
      hasHandled = true;
    } 
    
    if (!hasHandled) {
      appendMessage("bot", "No se ha encontrado información.");
    }

  } catch (err) {
    console.error("Error en sendAudio:", err);
    document.querySelector(".msg.bot:last-child")?.remove();
    appendMessage("bot", "Error al procesar el audio. " + err.message);
  }
}
// --- FIN NUEVAS FUNCIONES DE AUDIO ---


function renderMarkdownTable(tituloCohorte, tablaString, mensajeTotal) {
  const lines = tablaString.trim().split("\n").filter(l => l.includes("|"));
  if (lines.length < 2) return;

  const headers = lines[0].split("|").map(h => h.trim()).filter(Boolean);
  const rows = lines.slice(2).map(line => line.split("|").map(c => c.trim()).filter(Boolean));

  let html = "";
  if (tituloCohorte) {
    html += `<h3 style="text-align: left; margin-top: 0;">Cohorte: ${tituloCohorte}</h3>`;
  }

  html += "<table><thead><tr>";
  headers.forEach(h => html += `<th>${h}</th>`);
  html += "</tr></thead><tbody>";
  rows.forEach(r => html += "<tr>" + r.map(c => `<td>${c}</td>`).join("") + "</tr>");
  html += "</tbody></table>";

  if (mensajeTotal) {
    html += `<p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 12px;">${mensajeTotal}</p>`;
  }

  html += `<button id="verDatasetBtn">Ver resultado completo</button>`;
  
  document.getElementById("tablaContainer").innerHTML = html;
  document.getElementById("verDatasetBtn").addEventListener("click", enviarDataset);
}

function renderChartButtonsInChat() {
  const tipos = ["bar", "line", "scatter", "pie", "histogram"];
  let html = `<p><strong>El agente sugiere:</strong> selecciona el tipo de gráfico que deseas visualizar.</p><div class="btn-group">`;
  tipos.forEach(t => html += `<button class="btn-chart btn-alt" data-tipo="${t}">${t}</button>`);
  html += "</div>";
  
  const msgElement = appendMessage("bot", html, true);

  msgElement.querySelectorAll(".btn-chart").forEach(btn => 
    btn.addEventListener("click", () => manejarGrafico(btn.dataset.tipo))
  );
}

async function manejarGrafico(tipo) {
  appendMessage("bot", `Generando gráfico tipo '${tipo}'...`);
  try {
    const payload = {
      consulta: ultimaConsulta,
      sql: ultimaConsultaSQL,
    decision: tipo
    };

    const res = await fetch(webhookGraf, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    if (data.sql && data.x && data.y) {
      await renderChartFromSQL(data.sql, data.x, data.y, tipo);
    } else {
      appendMessage("bot", "Datos insuficientes para graficar.");
    }
  } catch {
    appendMessage("bot", "Error al conectar con el agente.");
}
}

async function renderChartFromSQL(sql, xField, yField, chartType) {
  try {
    const { data, error } = await supabase.rpc("execute_sql_query", { query: sql });
    if (error || !data?.length) {
      appendMessage("bot", "Sin resultados en la consulta para graficar.");
      return;
    }

    const labels = data.map(row => row[xField]);
    const values = data.map(row => parseFloat(row[yField])).filter(v => !isNaN(v));
    if (!values.length) {
      appendMessage("bot", "No hay valores numéricos válidos para graficar.");
      return;
    }

    const modal = document.getElementById("chartModal");
    modal.style.display = "flex";
    const ctx = document.getElementById("chartCanvas").getContext("2d");
    if (chartInstance) chartInstance.destroy();

    chartInstance = new Chart(ctx, {
      type: chartType === "histogram" ? "bar" : chartType,
      data: {
        labels,
        datasets: [{
          label: `${yField} vs ${xField}`,
          data: values,
          backgroundColor: "rgba(47,110,62,0.6)",
          borderColor: "rgba(47,110,62,1)",
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: { beginAtZero: true, title: { display: true, text: yField } },
          x: { title: { display: true, text: xField } }
        }
      }
    });
  } catch {
    appendMessage("bot", "Error al generar el gráfico desde Supabase.");
 }
}

async function enviarDataset() {
  if (!ultimaConsultaSQL) {
    appendMessage("bot", "No hay SQL disponible para enviar.");
    return;
  }
  appendMessage("bot", "Cargando dataset completo...");
  try {
    const res = await fetch(webhookData, {
      method: "POST",
     headers: {"Content-Type": "application/json"},
      body: JSON.stringify({ sql: ultimaConsultaSQL })
    });
    const data = await res.json();
    localStorage.setItem("datasetData", JSON.stringify(data));
    window.open("dataset.html", "_blank");
  } catch {
    appendMessage("bot", "Error al solicitar el dataset completo.");
  }
}

document.getElementById("closeModal").addEventListener("click", () => {
  document.getElementById("chartModal").style.display = "none";
});

// --- INICIO FUNCIONES GMAIL ---
function renderGmailButton(consulta) {
  const html = `
    <p><strong>Acción sugerida:</strong></p>
    <div class="btn-group">
      <button class="btn-chart btn-rec" id="gmailBtn">Generar Gmail</button>
    </div>`;
  
  const msgElement = appendMessage("bot", html, true);
  const button = msgElement.querySelector("#gmailBtn");

  if (button) {
    button.addEventListener("click", () => handleGmailGeneration(consulta));
  } else {
    console.error("Error: No se pudo adjuntar el listener al #gmailBtn");
  }
}

async function handleGmailGeneration(consulta) {
  const btn = document.getElementById("gmailBtn"); 
  if (btn) {
    btn.disabled = true;
    btn.textContent = "Generando...";
    btn.id = "";
  }
  
  appendMessage("bot", "Generando borrador de Gmail...");

  try {
    const payload = { "consulta": consulta };

    const res = await fetch(webhookGmail, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    document.querySelector(".msg.bot:last-child").remove(); 

    if (data.gmail) {
      const uniqueButtonId = `enviar-btn-${Date.now()}`;
      const emailHtml = `
        <div style="white-space: pre-wrap; background: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; padding: 12px;">
          ${data.gmail}
        </div>
        <div class="btn-group" style="margin-top: 10px;">
          <button class="btn-chart btn-rec" id="${uniqueButtonId}">Enviar Gmail</button>
        </div>
      `;
      
      const msgElement = appendMessage("bot", emailHtml, true);
      const sendButton = msgElement.querySelector(`#${uniqueButtonId}`);
      
      if (sendButton) {
        // Pasa el ID del botón y el cuerpo del email (data.gmail)
        sendButton.addEventListener("click", () => handleSendGmail(uniqueButtonId, data.gmail));
      }

    } else {
      appendMessage("bot", "No se pudo generar el cuerpo del Gmail.");
    }

  } catch (err) {
    document.querySelector(".msg.bot:last-child")?.remove();
    console.error("Error en handleGmailGeneration:", err);
    appendMessage("bot", "Error al conectar con el servicio de Gmail.");
  }
}

async function handleSendGmail(buttonId, emailBody) {
  const btn = document.getElementById(buttonId);
  if (!btn || btn.disabled) return;

  btn.disabled = true;
  btn.textContent = "Enviando...";

  try {
    const payload = { "output": emailBody };

    const res = await fetch(webhookEnviarGmail, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      throw new Error(`Error del servidor: ${res.statusText}`);
    }

    appendMessage("bot", "✅ Gmail Enviado Correctamente.");
    btn.style.display = 'none';

  } catch (err) {
    console.error("Error en handleSendGmail:", err);
    appendMessage("bot", "❌ Error al enviar el Gmail. Inténtalo de nuevo.");
    btn.disabled = false;
    btn.textContent = "Enviar Gmail";
  }
}
// --- FIN FUNCIONES GMAIL ---

</script>
</body>
</html>
