<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CohortLab – Visualizador Clínico</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lucide@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
:root { --verde:#2f6e3e; --verde-oscuro:#245831; --gris:#3b3b3b; --fondo:#f5f7f5; --card:#fff; --sombra:rgba(0,0,0,0.1);}
*{box-sizing:border-box}
body{font-family:"Poppins",sans-serif;margin:0;background:var(--fondo);color:var(--gris);height:100vh;display:flex;flex-direction:column;}
header{background:var(--card);display:flex;justify-content:space-between;align-items:center;padding:15px 40px;box-shadow:0 2px 8px var(--sombra);}
header h1{color:var(--verde);display:flex;align-items:center;gap:8px;font-size:1.1rem;}
header button{background:var(--verde);color:white;border:none;border-radius:8px;padding:8px 16px;cursor:pointer;}
header button:hover{background:var(--verde-oscuro);}

/* --- INICIO CAMBIO: CSS Responsivo (Móvil/Desktop) --- */
main {
    flex: 1;
    display: flex; /* Por defecto, apilado vertical (móvil) */
    flex-direction: column; 
    gap: 20px;
    padding: 20px;
    min-height: 0;
}

/* En pantallas grandes (tablets/escritorio), usamos el grid 50/50 */
@media (min-width: 768px) {
    main {
        display: grid;
        grid-template-columns: 1fr 1fr;
    }
}
/* --- FIN CAMBIO --- */

.chat-box, .tabla-box {
    background: var(--card);
    border-radius: 12px;
    box-shadow: 0 4px 10px var(--sombra);
    padding: 20px;
    display: flex;
    flex-direction: column;
    min-height: 0; /* Para el scroll vertical */
    min-width: 0;  /* Para que el contenido no rompa el grid */
}


/* --- CSS para layout 50/50 --- */
#tablaContainer {
    flex: 1; /* Hace que este div ocupe el espacio restante */
    overflow: auto; /* Añade scroll si la tabla es muy grande */
    min-height: 0; /* Asegura el comportamiento correcto del overflow en flex */
}

h2{text-align:center;color:var(--verde);margin:0 0 10px;}
.messages{flex:1;overflow:auto;background:#f8faf8;border-radius:10px;padding:15px;margin-bottom:10px;}
.msg{margin-bottom:12px;padding:12px 15px;border-radius:12px;max-width:100%;word-wrap:break-word;}
.msg.user{background:var(--verde);color:white;align-self:flex-end;}
.msg.bot{background:#e8f3e8;white-space:pre-wrap;align-self:flex-start;}

/* --- CSS de Audio --- */
.input-area{display:flex;gap:10px;}
input{flex:1;padding:10px;border:1px solid #ccc;border-radius:10px;min-width:0;}
button.action{
    background:var(--verde);
    color:white;
    border:none;
    border-radius:10px;
    padding:10px 14px;
    cursor:pointer;
    flex-shrink: 0; /* Impide que los botones se encojan */
    display:flex;
    align-items:center;
    justify-content:center;
}
button.action:hover{background:var(--verde-oscuro);}

/* Estilo para el botón de grabar */
button.action.is-recording {
    background: #e74c3c; /* Rojo mientras graba */
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
    100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
}
/* --- FIN CSS de Audio --- */

table{width:100%;border-collapse:collapse;margin-top:10px;font-size:0.9rem;}
/* Se añade white-space:nowrap para forzar el scroll horizontal en tablas */
th,td{border:1px solid #ddd;padding:10px;text-align:left; white-space: nowrap;} 

/* Encabezado de tabla fijo */
th{
    background:var(--verde);
    color:white;
    position: sticky; /* Se adhiere a la parte superior */
    top: 0;           /* Pega al borde superior del scroll */
    z-index: 1;       /* Asegura que esté por encima de las filas */
}

tr:nth-child(even){background:#f5f7f5;}
.btn-group{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
.btn-chart{padding:8px 12px;border:none;border-radius:6px;cursor:pointer;}
.btn-rec{background:var(--verde);color:white;}
.btn-alt{background:#e6e8e6;}
.btn-alt:hover{background:#d3d5d3;}
#verDatasetBtn{margin-top:12px;background:var(--verde);color:white;border:none;border-radius:8px;padding:10px 16px;cursor:pointer;width:100%;}
#verDatasetBtn:hover{background:var(--verde-oscuro);}

/* Modal de Gráfico */
#chartModal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999;padding:10px;}
#chartModalContent{background:white;padding:20px;border-radius:10px;width:90%;max-width:900px;box-shadow:0 0 10px rgba(0,0,0,0.3);}
#closeModal{background:var(--verde);color:white;border:none;padding:8px 12px;border-radius:6px;float:right;cursor:pointer;margin-bottom:10px;}
#chartWrap{width:100%;height:440px;}
#chartWrap canvas{width:100%!important;height:100%!important;}

/* --- INICIO: Nuevo Modal de Dataset --- */
#datasetModal{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.6);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:9998; /* Un poco menos que el de gráfico */
    padding: 10px; /* Margen para pantallas pequeñas */
}
#datasetModalContent{
    background:white;
    border-radius:10px;
    width:95%; /* Más ancho en móviles */
    max-width:1400px; /* Límite en escritorio */
    height: 90%; /* Ocupa casi toda la altura */
    box-shadow:0 0 10px rgba(0,0,0,0.3);
    display:flex;
    flex-direction:column; /* Para apilar header, info, tabla */
    padding: 20px;
}
#datasetModalHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #eee;
    padding-bottom: 15px;
    margin-bottom: 5px;
}
#datasetModalHeader h2 {
    margin: 0;
    text-align: left;
    font-size: 1.2rem;
}
#datasetModalHeader .btn-group {
    margin-top: 0;
}
#datasetInfo {
    text-align: center;
    font-size: 0.9rem;
    color: #555;
    margin-bottom: 15px;
    flex-shrink: 0;
}
#datasetTableWrapper {
    flex: 1; /* Ocupa todo el espacio restante */
    overflow: auto; /* Añade scroll vertical Y horizontal */
    min-height: 0;
}
/* Botones del modal (usamos los genéricos) */
.btn-modal-close {
    background: #777;
    color: white;
}
.btn-modal-close:hover {
    background: #555;
}
/* --- FIN: Nuevo Modal de Dataset --- */


footer{text-align:center;background:var(--card);padding:8px;color:#555;font-size:0.85rem;}
pre.debug{background:#222;color:#e3e3e3;padding:10px;border-radius:8px;overflow:auto}
</style>
</head>

<body>
<header>
  <h1><i data-lucide="stethoscope"></i> CohortLab – Asistente Clínico</h1>
  <button onclick="window.location.href='index.html'">Volver al Inicio</button>
</header>

<!-- --- INICIO CAMBIO DE ORDEN --- -->
<main>
  <!-- Columna de Chat (ahora a la izquierda) -->
  <div class="chat-box">
    <h2>Chat con el Agente</h2>
    <div id="messages" class="messages"></div>
    <div class="input-area">
      <input id="userInput" placeholder="Escribe tu mensaje o graba un audio...">
      <button class="action" id="sendBtn"><i data-lucide="send"></i></button>
      <button class="action" id="micBtn"><i data-lucide="mic"></i></button>
  </div>
  </div>

  <!-- Columna de Resultados (ahora a la derecha) -->
  <div class="tabla-box">
    <h2>Resultados</h2>
    <div id="tablaContainer">Esperando resultados...</div>
  </div>
</main>
<!-- --- FIN CAMBIO DE ORDEN --- -->


<!-- Modal gráfico -->
<div id="chartModal">
  <div id="chartModalContent">
    <button id="closeModal">Cerrar</button>
    <div id="chartWrap"><canvas id="chartCanvas"></canvas></div>
  </div>
</div>

<!-- --- INICIO: Nuevo Modal HTML para Dataset --- -->
<div id="datasetModal">
    <div id="datasetModalContent">
        <!-- Cabecera del Modal -->
        <div id="datasetModalHeader">
            <h2><i data-lucide="database" style="width:20px; margin-right: 8px;"></i>Dataset Completo</h2>
            <div class="btn-group">
                <button class="btn-chart btn-rec" id="downloadCsvBtn">
                    <i data-lucide="download" style="width:14px; margin-right: 5px;"></i>Descargar CSV
                </button>
                <button class="btn-chart btn-modal-close" id="closeDatasetModal">Cerrar</button>
            </div>
        </div>
        
        <!-- Info de registros -->
        <div id="datasetInfo">Cargando...</div>
        
        <!-- Contenedor de la tabla con scroll -->
        <div id="datasetTableWrapper">
            <!-- La tabla se generará aquí por JS -->
        </div>
    </div>
</div>
<!-- --- FIN: Nuevo Modal HTML para Dataset --- -->


<footer>© 2025 CohortIQ – Plataforma Inteligente de Apoyo Clínico</footer>

<script>
lucide.createIcons();

// --- URLs de Webhooks (actualizadas por ti) ---
const webhookText = "https://rubaseval.app.n8n.cloud/webhook/dedaluschataudio";
const webhookGraf = "https://rubaseval.app.n8n.cloud/webhook/grafico";
const webhookData = "https://rubaseval.app.n8n.cloud/webhook/dataset";
const webhookGmail = "https://rubaseval.app.n8n.cloud/webhook/escribir-gmail"; 
const webhookEnviarGmail = "https://rubaseval.app.n8n.cloud/webhook/enviar-gmail";
// --- Fin URLs Webhooks ---

const supabaseUrl = "https://tmolxeszsgkffurhrcxy.supabase.co";
const supabaseKey = "eyJhbGciOiJIZzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRtb2x4ZXN6c2drZmZ1cmhyY3h5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA5ODA4NDgsImV4cCI6MjA3NjU1Njg0OH0.UAEsNX7CpFXbns9ONynstAAKdcvmZUfsX5J6cOTE6Pw";
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

let ultimaConsulta = "";
let ultimaConsultaSQL = "";
let ultimaX = "";
let ultimaY = "";
let chartInstance = null;

// --- INICIO NUEVAS VARIABLES AUDIO ---
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
const micBtn = document.getElementById("micBtn");
// --- FIN NUEVAS VARIABLES AUDIO ---

// --- INICIO: Variables de Memoria ---
let conversationHistory = [];
const MAX_HISTORY_TURNS = 5; // 5 turnos (5 user, 5 bot = 10 items)
// --- FIN: Variables de Memoria ---

// --- INICIO: Variables para CSV ---
let currentDataset = { columns: [], rows: [] };
// --- FIN: Variables para CSV ---


// Event Listeners (Texto y Enter)
document.addEventListener("keydown", e => { if (e.key === "Enter" && document.getElementById("userInput") === document.activeElement) sendText(); });
document.getElementById("sendBtn").addEventListener("click", sendText);

// --- INICIO NUEVO EVENT LISTENER AUDIO ---
micBtn.addEventListener("click", toggleRecording);
// --- FIN NUEVO EVENT LISTENER AUDIO ---

// --- INICIO: Listeners Modales ---
document.getElementById("closeModal").addEventListener("click", () => {
  document.getElementById("chartModal").style.display = "none";
});
document.getElementById("closeDatasetModal").addEventListener("click", () => {
    document.getElementById("datasetModal").style.display = "none";
});
document.getElementById("downloadCsvBtn").addEventListener("click", downloadCSV);
// --- FIN: Listeners Modales ---


// --- INICIO: Funciones de Memoria ---

/**
 * Borra el historial antiguo, manteniendo solo los últimos MAX_HISTORY_TURNS
 */
function pruneHistory() {
    const maxItems = MAX_HISTORY_TURNS * 2; // (user + bot)
    if (conversationHistory.length > maxItems) {
        // Elimina los items más antiguos del principio del array
        conversationHistory.splice(0, conversationHistory.length - maxItems);
    }
}

/**
 * Prepara el string de historial SOLO con las consultas del usuario
 * @returns {string} - El string formateado.
 */
function getFormattedUserHistoryString() {
    // 1. Filtra solo las entradas del usuario
    const userQueries = conversationHistory
        .filter(item => item.role === 'user')
        .map(item => item.content); // 2. Obtiene solo el texto
    
    if (userQueries.length === 0) {
        return ""; // Devuelve vacío si no hay historial
    }
    
    // 3. Formatea el string
    const header = "Consultas anteriores:\n";
    const queriesList = userQueries.map(q => `- ${q}`).join("\n");
    
    return `${header}${queriesList}`;
}
// --- FIN: Funciones de Memoria ---


function appendMessage(sender, text, html = false) {
  const msg = document.createElement("div");
  msg.className = "msg " + sender;
  msg.innerHTML = html ? text : text.replace(/\n/g, "<br>");
  const box = document.getElementById("messages");
  box.appendChild(msg);
  box.scrollTop = box.scrollHeight;
  return msg; // Devuelve el elemento para adjuntar listeners
}

async function sendText() {
  const input = document.getElementById("userInput");
  const text = input.value.trim();
  if (!text) return;

  // Prepara el historial ANTES de añadir el mensaje actual
  const historyString = getFormattedUserHistoryString();
  
  // Añade el mensaje actual al historial
  conversationHistory.push({ role: 'user', content: text });
  
  appendMessage("user", text);
  input.value = "";
  const loadingMsg = appendMessage("bot", "Consultando al agente...");

  try {
    const res = await fetch(webhookText, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({
          type:"text", 
          content: text,
          history: historyString // Envía el historial de usuario formateado
      })
    });
    
    const rawResponse = await res.text();
    if (!rawResponse) {
        throw new Error("Respuesta vacía del servidor (webhook)");
    }
    
    const data = JSON.parse(rawResponse);

    loadingMsg.remove(); // Quita el "Consultando..."

    let hasHandled = false; 
    let botResponse = ""; // Variable para guardar la respuesta del bot

    if (data.tabla) {
      renderMarkdownTable(data.cohorte, data.tabla, data.n_total);
      ultimaConsulta = data.consulta || text; // Usa la consulta reescrita si existe
      ultimaConsultaSQL = data.sql || "";
      // Prepara una respuesta de bot para el historial
      botResponse = `[Mostrando tabla para la cohorte: ${data.cohorte || 'Resultados'}]`;
      hasHandled = true;
    }

    if (data.gmail && data.gmail === "True") {
      renderGmailButton(data.consulta || text);
      botResponse = `[Acción sugerida: Generar Gmail]`; // Respuesta para el historial
      hasHandled = true;
    }

    if (data.respuesta && !data.tabla) {
      appendMessage("bot", data.respuesta);
      botResponse = data.respuesta; // Respuesta de texto para el historial
      hasHandled = true;
    } 
    
    if (!hasHandled) {
      const errorTxt = "No se ha encontrado información.";
      appendMessage("bot", errorTxt);
      botResponse = errorTxt;
    }

    // Guarda la respuesta del bot (lo que sea) en el historial
    conversationHistory.push({ role: 'bot', content: botResponse });
    pruneHistory(); // Limpia el historial si es necesario

  } catch (err) {
    console.error("Error en sendText:", err);
    loadingMsg?.remove();
    const errorTxt = "Error al conectar con el agente. " + err.message;
    appendMessage("bot", errorTxt);
    // Guarda el error en el historial para contexto
    conversationHistory.push({ role: 'bot', content: `[Error: ${err.message}]` });
    pruneHistory();
  }
}


// --- INICIO NUEVAS FUNCIONES DE AUDIO ---

function toggleRecording() {
  if (!isRecording) {
    startRecording();
  } else {
    stopRecording();
  }
}

async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    
    mediaRecorder.ondataavailable = event => {
      audioChunks.push(event.data);
    };
    
    mediaRecorder.onstop = () => {
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      audioChunks = [];
      sendAudio(audioBlob); // Envía el Blob binario
    };
    
    mediaRecorder.start();
    isRecording = true;
    micBtn.innerHTML = `<i data-lucide="stop-circle"></i>`;
    micBtn.classList.add("is-recording");
    lucide.createIcons();
  } catch (err) {
    console.error("Error starting recording:", err);
    appendMessage("bot", "Error al acceder al micrófono. Asegúrate de dar permiso.");
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
    isRecording = false;
    micBtn.innerHTML = `<i data-lucide="mic"></i>`;
    micBtn.classList.remove("is-recording");
    lucide.createIcons();
    mediaRecorder.stream.getTracks().forEach(track => track.stop());
  }
}

async function sendAudio(audioBlob) {
  const loadingMsg = appendMessage("bot", "Procesando audio...");
  
  // Prepara el historial ANTES de enviar
  const historyString = getFormattedUserHistoryString();

  try {
    const formData = new FormData();
    formData.append('file', audioBlob, 'audio.webm'); 
    formData.append('history', historyString); // Añade el historial al FormData

    const res = await fetch(webhookText, {
      method: "POST",
      body: formData
    });
    
    const rawResponse = await res.text();
    if (!rawResponse) {
        throw new Error("Respuesta vacía del servidor (webhook)");
    }

    const data = JSON.parse(rawResponse);

    loadingMsg.remove(); // Quita "Procesando..."

    let hasHandled = false; 
    let botResponse = ""; // Para el historial
    let userQuery = "[Consulta de audio]"; // Default por si no viene transcripción

    if (data.consulta) {
        appendMessage("user", `[Audio] ${data.consulta}`);
        userQuery = data.consulta; // Transcripción para el historial
        ultimaConsulta = data.consulta;
    }
    
    // Guarda la transcripción del usuario en el historial
    conversationHistory.push({ role: 'user', content: userQuery });

    if (data.tabla) {
      renderMarkdownTable(data.cohorte, data.tabla, data.n_total);
      ultimaConsultaSQL = data.sql || "";
      botResponse = `[Mostrando tabla para la cohorte: ${data.cohorte || 'Resultados'}]`;
      hasHandled = true;
    }

    if (data.gmail && data.gmail === "True") {
      renderGmailButton(data.consulta || "Acción de audio"); 
      botResponse = `[Acción sugerida: Generar Gmail]`;
      hasHandled = true;
    }

    if (data.respuesta && !data.tabla) {
      appendMessage("bot", data.respuesta);
      botResponse = data.respuesta;
      hasHandled = true;
    } 
    
    if (!hasHandled) {
      const errorTxt = "No se ha encontrado información.";
      appendMessage("bot", errorTxt);
      botResponse = errorTxt;
    }
    
    // Guarda la respuesta del bot en el historial
    conversationHistory.push({ role: 'bot', content: botResponse });
    pruneHistory(); // Limpia el historial

  } catch (err) {
    console.error("Error en sendAudio:", err);
    loadingMsg?.remove();
    const errorTxt = "Error al procesar el audio. " + err.message;
    appendMessage("bot", errorTxt);
    // Guarda el error en el historial
    conversationHistory.push({ role: 'user', content: '[Consulta de audio fallida]' });
    conversationHistory.push({ role: 'bot', content: `[Error: ${err.message}]` });
    pruneHistory();
  }
}
// --- FIN NUEVAS FUNCIONES DE AUDIO ---


/**
 * Renderiza la tabla de resumen en el panel derecho.
 * (Versión robusta que maneja celdas vacías y formatos)
 */
function renderMarkdownTable(tituloCohorte, tablaString, mensajeTotal) {
    if (!tablaString) return;
    
    const lines = tablaString.trim().split("\n");
    if (lines.length < 2) return; // Necesita cabecera y separador

    // Función limpia para parsear una línea de tabla
    const parseRow = (rowString) => {
        // 1. Quita los pipes de los bordes (si existen)
        let cleanRow = rowString.trim();
        if (cleanRow.startsWith('|')) cleanRow = cleanRow.substring(1);
        if (cleanRow.endsWith('|')) cleanRow = cleanRow.slice(0, -1);
        // 2. Divide por el pipe y limpia cada celda
        return cleanRow.split('|').map(cell => cell.trim());
    };

    const headers = parseRow(lines[0]);
    // lines[1] es el separador '---|---|---', lo saltamos
    const rows = lines.slice(2).map(parseRow);

    let html = "";
    if (tituloCohorte) {
        html += `<h3 style="text-align: left; margin-top: 0;">Cohorte: ${tituloCohorte}</h3>`;
    }

    html += "<table><thead><tr>";
    headers.forEach(h => html += `<th>${h}</th>`);
    html += "</tr></thead><tbody>";
    
    rows.forEach(r => {
        html += "<tr>";
        // Itera usando los headers para asegurar el número correcto de celdas
        headers.forEach((_, index) => {
            const cellData = r[index] || ""; // Pone "" si la celda está indefinida
            html += `<td>${cellData}</td>`;
        });
        html += "</tr>";
    });
    
    html += "</tbody></table>";

    if (mensajeTotal) {
        html += `<p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 12px;">${mensajeTotal}</p>`;
    }

    html += `<button id="verDatasetBtn">Ver resultado completo</button>`;
    
    document.getElementById("tablaContainer").innerHTML = html;
    
    // El botón SÓLO puede existir después de renderizar la tabla
    const btn = document.getElementById("verDatasetBtn");
    if (btn) {
        btn.addEventListener("click", enviarDataset);
    }
}

function renderChartButtonsInChat() {
  const tipos = ["bar", "line", "scatter", "pie", "histogram"];
  let html = `<p><strong>El agente sugiere:</strong> selecciona el tipo de gráfico que deseas visualizar.</p><div class="btn-group">`;
  tipos.forEach(t => html += `<button class="btn-chart btn-alt" data-tipo="${t}">${t}</button>`);
  html += "</div>";
  
  const msgElement = appendMessage("bot", html, true);

  msgElement.querySelectorAll(".btn-chart").forEach(btn => 
    btn.addEventListener("click", () => manejarGrafico(btn.dataset.tipo))
  );
}

async function manejarGrafico(tipo) {
  appendMessage("bot", `Generando gráfico tipo '${tipo}'...`);
  try {
    const payload = {
      consulta: ultimaConsulta,
      sql: ultimaConsultaSQL,
      decision: tipo
    };

    const res = await fetch(webhookGraf, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    if (data.sql && data.x && data.y) {
      await renderChartFromSQL(data.sql, data.x, data.y, tipo);
    } else {
      appendMessage("bot", "Datos insuficientes para graficar.");
    }
  } catch {
    appendMessage("bot", "Error al conectar con el agente.");
}
}

async function renderChartFromSQL(sql, xField, yField, chartType) {
  try {
    const { data, error } = await supabase.rpc("execute_sql_query", { query: sql });
    if (error || !data?.length) {
      appendMessage("bot", "Sin resultados en la consulta para graficar.");
      return;
    }

    const labels = data.map(row => row[xField]);
    const values = data.map(row => parseFloat(row[yField])).filter(v => !isNaN(v));
    if (!values.length) {
      appendMessage("bot", "No hay valores numéricos válidos para graficar.");
      return;
    }

    const modal = document.getElementById("chartModal");
    modal.style.display = "flex";
    const ctx = document.getElementById("chartCanvas").getContext("2d");
    if (chartInstance) chartInstance.destroy();

    chartInstance = new Chart(ctx, {
      type: chartType === "histogram" ? "bar" : chartType,
      data: {
        labels,
        datasets: [{
          label: `${yField} vs ${xField}`,
          data: values,
          backgroundColor: "rgba(47,110,62,0.6)",
          borderColor: "rgba(47,110,62,1)",
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: { beginAtZero: true, title: { display: true, text: yField } },
          x: { title: { display: true, text: xField } }
        }
      }
    });
  } catch {
    appendMessage("bot", "Error al generar el gráfico desde Supabase.");
 }
}

// --- INICIO: Funciones de Modal de Dataset (Modificadas) ---

async function enviarDataset() {
    if (!ultimaConsultaSQL) {
        appendMessage("bot", "No hay SQL disponible para enviar.");
        return;
    }
    const loadingMsg = appendMessage("bot", "Cargando dataset completo...");
    
    try {
        const res = await fetch(webhookData, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({ sql: ultimaConsultaSQL })
        });
        const data = await res.json();
        
        // Llama a la nueva función para renderizar el modal
        renderDatasetModal(data);
        loadingMsg.remove(); // Quita "Cargando..."
        
    } catch(err) {
        console.error("Error en enviarDataset:", err);
        loadingMsg?.remove();
        appendMessage("bot", "Error al solicitar el dataset completo.");
    }
}

/**
 * Renderiza los datos completos en el modal
 * @param {object} data - El objeto JSON con {columns, rows, total_registros, sql}
 */
function renderDatasetModal(data) {
    const tableWrapper = document.getElementById('datasetTableWrapper');
    const infoContainer = document.getElementById('datasetInfo');
    const modal = document.getElementById('datasetModal');

    // Limpia el contenido anterior
    tableWrapper.innerHTML = "";
    infoContainer.innerHTML = "";
    
    try {
        // 1. Parsear las propiedades 'columns' y 'rows' (que son strings)
        const columns = JSON.parse(data.columns);
        const rows = JSON.parse(data.rows);
        const total = data.total_registros;
        const sql = data.sql || "No se proporcionó SQL.";

        // Guarda los datos para el CSV
        currentDataset = { columns, rows };

        // 2. Actualizar el contador de registros
        infoContainer.innerHTML = `
            <strong>Total de registros:</strong> ${total} <br>
            <small style="color: #777;"><strong>Consulta SQL:</strong> ${sql}</small>
        `;

        // 3. Construir la tabla HTML
        let html = "<table>";
        
        // Cabecera
        html += "<thead><tr>";
        columns.forEach(col => {
            html += `<th>${col}</th>`;
        });
        html += "</tr></thead>";
        
        // Cuerpo
        html += "<tbody>";
        rows.forEach(row => {
            html += "<tr>";
            row.forEach(cell => {
                html += `<td>${cell !== null ? cell : ""}</td>`;
            });
            html += "</tr>";
        });
        html += "</tbody></table>";
        
        // 4. Insertar la tabla en el DOM
        tableWrapper.innerHTML = html;
        
        // 5. Mostrar el modal
        modal.style.display = "flex";
        lucide.createIcons(); // Recarga iconos por si hay en el modal

    } catch (e) {
        console.error("Error al parsear o renderizar los datos del modal:", e);
        infoContainer.innerText = "Error al procesar los datos.";
        tableWrapper.innerHTML = `<p style='text-align:center;'>Ocurrió un error: ${e.message}</p>`;
        modal.style.display = "flex"; // Muestra el modal incluso si hay error
    }
}

/**
 * Función para descargar los datos del modal como CSV
 */
function downloadCSV() {
    const { columns, rows } = currentDataset;
    if (!columns || columns.length === 0 || !rows) {
        appendMessage("bot", "No hay datos para descargar.");
        return;
    }

    // 1. Prepara el contenido CSV
    let csvContent = "data:text/csv;charset=utf-8,";

    // 2. Añade la cabecera (columnas)
    // Maneja comas en los nombres de columnas (poco probable, pero seguro)
    const header = columns.map(col => `"${col.replace(/"/g, '""')}"`).join(",");
    csvContent += header + "\r\n";

    // 3. Añade las filas
    rows.forEach(row => {
        const rowString = row.map(cell => {
            let cellString = String(cell === null || cell === undefined ? "" : cell);
            // Escapa comillas dobles duplicándolas
            cellString = cellString.replace(/"/g, '""');
            // Envuelve la celda en comillas si contiene comas, saltos de línea o comillas
            if (cellString.includes(",") || cellString.includes("\n") || cellString.includes('"')) {
                return `"${cellString}"`;
            }
            return cellString;
        }).join(",");
        csvContent += rowString + "\r\n";
    });

    // 4. Crea y simula el clic en el enlace de descarga
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "cohortiq_dataset.csv");
    document.body.appendChild(link); // Necesario para Firefox

    link.click();
    document.body.removeChild(link);
}
// --- FIN: Funciones de Modal de Dataset ---


// --- INICIO FUNCIONES GMAIL ---
function renderGmailButton(consulta) {
  const html = `
    <p><strong>Acción sugerida:</strong></p>
    <div class="btn-group">
      <button class="btn-chart btn-rec" id="gmailBtn">Generar Gmail</button>
    </div>`;
  
  const msgElement = appendMessage("bot", html, true);
  const button = msgElement.querySelector("#gmailBtn");

  if (button) {
    button.addEventListener("click", () => handleGmailGeneration(consulta));
  } else {
    console.error("Error: No se pudo adjuntar el listener al #gmailBtn");
  }
}

async function handleGmailGeneration(consulta) {
  // Busca el botón por clase dentro del último mensaje, no por ID
  const btn = document.querySelector(".msg.bot:last-child #gmailBtn"); 
  if (btn) {
    btn.disabled = true;
    btn.textContent = "Generando...";
    btn.id = ""; // Quita ID para evitar duplicados
  }
  
  appendMessage("bot", "Generando borrador de Gmail...");

  try {
    const payload = { "consulta": consulta };

    const res = await fetch(webhookGmail, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    document.querySelector(".msg.bot:last-child").remove(); 

    if (data.gmail) {
      const uniqueButtonId = `enviar-btn-${Date.now()}`;
      const emailHtml = `
        <div style="white-space: pre-wrap; background: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; padding: 12px; font-size: 0.9rem;">
          ${data.gmail}
        </div>
        <div class="btn-group" style="margin-top: 10px;">
          <button class="btn-chart btn-rec" id="${uniqueButtonId}">Enviar Gmail</button>
        </div>
      `;
      
      const msgElement = appendMessage("bot", emailHtml, true);
      const sendButton = msgElement.querySelector(`#${uniqueButtonId}`);
      
      if (sendButton) {
        // Pasa el ID del botón y el cuerpo del email (data.gmail)
        sendButton.addEventListener("click", () => handleSendGmail(uniqueButtonId, data.gmail));
      }

    } else {
      appendMessage("bot", "No se pudo generar el cuerpo del Gmail.");
    }

  } catch (err) {
    document.querySelector(".msg.bot:last-child")?.remove();
    console.error("Error en handleGmailGeneration:", err);
    appendMessage("bot", "Error al conectar con el servicio de Gmail.");
  }
}

async function handleSendGmail(buttonId, emailBody) {
  const btn = document.getElementById(buttonId);
  if (!btn || btn.disabled) return;

  btn.disabled = true;
  btn.textContent = "Enviando...";

  try {
    const payload = { "output": emailBody };

    const res = await fetch(webhookEnviarGmail, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      throw new Error(`Error del servidor: ${res.statusText}`);
    }

    appendMessage("bot", "✅ Gmail Enviado Correctamente.");
    btn.style.display = 'none';

  } catch (err) {
    console.error("Error en handleSendGmail:", err);
    appendMessage("bot", "❌ Error al enviar el Gmail. Inténtalo de nuevo.");
    btn.disabled = false;
    btn.textContent = "Enviar Gmail";
  }
}
// --- FIN FUNCIONES GMAIL ---

</script>
</body>
</html>

